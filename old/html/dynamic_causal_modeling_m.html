
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Variational Gradient Matching for Dynamical Systems: Dynamic Causal Modeling</title><meta name="generator" content="MATLAB 9.2"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-04-18"><meta name="DC.source" content="dynamic_causal_modeling_m.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Variational Gradient Matching for Dynamical Systems: Dynamic Causal Modeling</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">,</a></li><li><a href="#2"><b>Authors</b>:</a></li><li><a href="#3">Contents:</a></li><li><a href="#4">User Input: Simulation Settings</a></li><li><a href="#10">User Input: Estimation</a></li><li><a href="#15">Preprocessing</a></li><li><a href="#17">Mass Action Dynamical Systems</a></li><li><a href="#19">Simulate Trajectories</a></li><li><a href="#28">Prior on States and State Derivatives</a></li><li><a href="#29">Matching Gradients</a></li><li><a href="#32">Rewrite ODEs as Linear Combination in Parameters</a></li><li><a href="#35">Posterior over ODE Parameters</a></li><li><a href="#37">Rewrite Hemodynamic ODEs as Linear Combination in (monotonic functions of) Individual Hemodynamic States</a></li><li><a href="#43">Rewrite Neuronal ODEs as Linear Combination in Individual Neuronal States</a></li><li><a href="#46">Posterior over Individual States</a></li><li><a href="#48">Mean-field Variational Inference</a></li><li><a href="#51">Denoising BOLD Observations</a></li><li><a href="#55">Fitting observations of state trajectories</a></li><li><a href="#58">Coordinate Ascent Variational Gradient Matching</a></li><li><a href="#61">*                           *</a></li><li><a href="#62"><b>Intercept due to Confounding Effects</b></a></li><li><a href="#67">Proxy for Hemodynamic States</a></li><li><a href="#76">Proxy for Neuronal States</a></li><li><a href="#79">*            *</a></li><li><a href="#80"></a></li><li><a href="#81"><b>Proxy for ODE parameters</b></a></li><li><a href="#86"></a></li><li><a href="#87"></a></li><li><a href="#88"><b>Numerical Integration with Estimated ODE Parameters</b></a></li><li><a href="#92">Time Taken</a></li><li><a href="#95">References</a></li></ul></div><h2 id="1">,</h2><h2 id="2"><b>Authors</b>:</h2><p><b>Nico Stephan Gorbach</b> and <b>Stefan Bauer</b>, email: <a href="mailto:nico.gorbach@gmail.com">nico.gorbach@gmail.com</a></p><h2 id="3">Contents:</h2><p>Instructional code for the NIPS (2018) paper <a href="https://papers.nips.cc/paper/7066-scalable-variational-inference-for-dynamical-systems.pdf">Scalable Variational Inference for Dynamical Systems</a> by Nico S. Gorbach, Stefan Bauer and Joachim M. Buhmann. Please cite our paper if you use our program for a further publication. Part of the derivation below is described in Wenk et al. (2018). Example dynamical system used in this code:* Lorenz attractor* system with the* y-dimension unobserved*. The ODE parameters are also unobserved.</p><pre class="codeinput">clear <span class="string">all</span>; close <span class="string">all</span>;
</pre><pre class="codeoutput">Warning: The file
'/Applications/MATLAB_R2017a.app/toolbox/matlab/codetools/private/evalmxdom.m'
could not be cleared because it contains MATLAB code that is currently
executing. 
Warning: The file
'/Users/nico/Documents/Thesis/Thesis_compact/scalable_dynamics/code_publish/dynamic_causal_modeling_m.m'
could not be cleared because it contains MATLAB code that is currently
executing. 
Warning: The file
'/Applications/MATLAB_R2017a.app/toolbox/matlab/codetools/mdbpublish.m' could
not be cleared because it contains MATLAB code that is currently executing. 
Warning: The file
'/Applications/MATLAB_R2017a.app/toolbox/matlab/codetools/publish.p' could not
be cleared because it contains MATLAB code that is currently executing. 
Warning: The file
'/Applications/MATLAB_R2017a.app/toolbox/matlab/codetools/private/evalmxdom.m'
could not be cleared because it contains MATLAB code that is currently
executing. 
Warning: The file
'/Users/nico/Documents/Thesis/Thesis_compact/scalable_dynamics/code_publish/dynamic_causal_modeling_m.m'
could not be cleared because it contains MATLAB code that is currently
executing. 
Warning: The file
'/Applications/MATLAB_R2017a.app/toolbox/matlab/codetools/mdbpublish.m' could
not be cleared because it contains MATLAB code that is currently executing. 
Warning: The file
'/Applications/MATLAB_R2017a.app/toolbox/matlab/codetools/publish.p' could not
be cleared because it contains MATLAB code that is currently executing. 
Warning: The file
'/Applications/MATLAB_R2017a.app/toolbox/matlab/codetools/private/evalmxdom.m'
could not be cleared because it contains MATLAB code that is currently
executing. 
Warning: The file
'/Users/nico/Documents/Thesis/Thesis_compact/scalable_dynamics/code_publish/dynamic_causal_modeling_m.m'
could not be cleared because it contains MATLAB code that is currently
executing. 
Warning: The file
'/Applications/MATLAB_R2017a.app/toolbox/matlab/codetools/mdbpublish.m' could
not be cleared because it contains MATLAB code that is currently executing. 
Warning: The file
'/Applications/MATLAB_R2017a.app/toolbox/matlab/codetools/publish.p' could not
be cleared because it contains MATLAB code that is currently executing. 
</pre><h2 id="4">User Input: Simulation Settings</h2><div><ul><li><b>Simulation ODEs</b></li></ul></div><pre class="codeinput">        simulation.odes = <span class="string">'fwd_mod_driving'</span>;
</pre><div><ul><li><b>final time for simulation:</b></li></ul></div><pre class="codeinput">        simulation.final_time = 359*3.22;
</pre><div><ul><li><b>observation noise:</b></li></ul></div><pre class="codeinput">        simulation.state_obs_variance = @(x)(bsxfun(@rdivide,var(x),5));
</pre><div><ul><li><b>time interval between observations:</b></li></ul></div><pre class="codeinput">        simulation.interval_between_observations = 0.1;
</pre><p></p><h2 id="10">User Input: Estimation</h2><div><ul><li><b>Candidate ODEs</b></li></ul></div><pre class="codeinput">        candidate_odes = <span class="string">'fwd_mod_driving'</span>;
</pre><div><ul><li><b>Kernel</b></li></ul></div><pre>               Kernel parameters $\mathbf\phi$:</pre><pre class="codeinput">        kernel.param = [10,0.2];
</pre><div><ul><li><b>Error variance on state derivatives (i.e.</b> <img src="dynamic_causal_modeling_m_eq17096441642737911057.png" alt="$\gamma$" style="width:6px;height:8px;">*)*:</li></ul></div><pre class="codeinput">        state.derivative_variance = 6.*ones(11-3,1);
</pre><div><ul><li><b>Estimation times</b></li></ul></div><pre class="codeinput">        time.est = 0:3.22:359*3.22;
</pre><h2 id="15">Preprocessing</h2><pre class="codeinput">[symbols,simulation,ode,odes_path,coupling_idx,opt_settings,plot_settings,state] = preprocessing_dynamic_causal_modeling (simulation,candidate_odes,state);
</pre><pre class="codeoutput"> 
ODEs:
 
 - (5*exp((17*v_1)/8))/8 - (25*exp(-q_1)*exp(f_1)*((3/5)^exp(-f_1) - 1))/16
 - (5*exp((17*v_3)/8))/8 - (25*exp(-q_3)*exp(f_3)*((3/5)^exp(-f_3) - 1))/16
 - (5*exp((17*v_2)/8))/8 - (25*exp(-q_2)*exp(f_2)*((3/5)^exp(-f_2) - 1))/16
                           (5*exp(-v_1)*exp(f_1))/8 - (5*exp((17*v_1)/8))/8
                           (5*exp(-v_3)*exp(f_3))/8 - (5*exp((17*v_3)/8))/8
                           (5*exp(-v_2)*exp(f_2))/8 - (5*exp((17*v_2)/8))/8
                                                              s_1*exp(-f_1)
                                                              s_3*exp(-f_3)
                                                              s_2*exp(-f_2)
                                   n_1 - (3*s_1)/5 - (8*exp(f_1))/25 + 8/25
                                   n_3 - (3*s_3)/5 - (8*exp(f_3))/25 + 8/25
                                   n_2 - (3*s_2)/5 - (8*exp(f_2))/25 + 8/25
                                             a_11*n_1 + a_12*n_2 + c_11*u_1
                                             a_32*n_2 + a_33*n_3 + c_33*u_3
                   a_22*n_2 + a_23*n_3 + n_1*(a_21 + b_212*u_2 + b_213*u_3)
 
</pre><h2 id="17">Mass Action Dynamical Systems</h2><p>A deterministic dynamical system is represented by a set of <img src="dynamic_causal_modeling_m_eq03845174387838694102.png" alt="$K$" style="width:10px;height:8px;"> ordinary differential equations (ODEs) with model parameters <img src="dynamic_causal_modeling_m_eq18305986736779408640.png" alt="$\mathbf\theta \in \mathcal{R}^d$" style="width:33px;height:10px;"> that describe the evolution of <img src="dynamic_causal_modeling_m_eq03845174387838694102.png" alt="$K$" style="width:10px;height:8px;"> states <img src="dynamic_causal_modeling_m_eq16690292594929342180.png" alt="$\mathbf{x}(t) = [x_1(t),\ldots, x_K(t)]^T$" style="width:120px;height:13px;"> such that:</p><p><img src="dynamic_causal_modeling_m_eq15519211153938804350.png" alt="$\dot{\mathbf{x}}(t) = \frac{d \mathbf{x}(t)}{d t} = \mathbf{f}(\mathbf{x}(t),\mathbf\theta) \qquad (1)$" style="width:147px;height:16px;">,</p><p>A sequence of observations, <img src="dynamic_causal_modeling_m_eq17565748849429239454.png" alt="$\mathbf{y}(t)$" style="width:19px;height:11px;">, is usually contaminated by measurement error which we assume to be normally distributed with zero mean and variance for each of the <img src="dynamic_causal_modeling_m_eq03845174387838694102.png" alt="$K$" style="width:10px;height:8px;"> states, i.e. <img src="dynamic_causal_modeling_m_eq00997383903036395961.png" alt="$\mathbf{E}\sim\mathcal{N}(\mathbf{E};\mathbf{0},\mathbf{D})$" style="width:75px;height:12px;">, with <img src="dynamic_causal_modeling_m_eq02125912780065424198.png" alt="$\mathbf{D}_{ik}=\sigma_k ^2 \delta_{ik}$" style="width:55px;height:13px;">. For <img src="dynamic_causal_modeling_m_eq03672095713503266041.png" alt="$N$" style="width:10px;height:8px;"> distinct time points the overall system may therefore be summarized as</p><p><img src="dynamic_causal_modeling_m_eq05988414051423361030.png" alt="$\mathbf{Y} = \mathbf{X} + \mathbf{E}$" style="width:56px;height:9px;">,</p><p>where</p><p><img src="dynamic_causal_modeling_m_eq13585074033575565705.png" alt="$\mathbf{X} = [\mathbf{x}(t_1),\ldots,\mathbf{x}(t_N)] =  [\mathbf{x}_1,\ldots,\mathbf{x}_K]^T$" style="width:181px;height:13px;">,</p><p><img src="dynamic_causal_modeling_m_eq05721247787040501698.png" alt="$\mathbf{Y} = [\mathbf{y}(t_1),\ldots,\mathbf{y}(t_N)] =  [\mathbf{y}_1,\ldots,\mathbf{y}_K]^T$" style="width:182px;height:13px;">,</p><p>and <img src="dynamic_causal_modeling_m_eq15380491105506292187.png" alt="$\mathbf{x}_k = [x_k(t_1),\ldots,x_k(t_N)]^T$" style="width:122px;height:13px;"> is the <img src="dynamic_causal_modeling_m_eq15636846968047188835.png" alt="$k$" style="width:6px;height:8px;">'th state sequence and <img src="dynamic_causal_modeling_m_eq05965047012017685170.png" alt="$\mathbf{y}_k = [y_k(t_1),\ldots,y_k(t_N)]^T$" style="width:120px;height:13px;"> are the observations. Given the observations <img src="dynamic_causal_modeling_m_eq00013651220649516337.png" alt="$\mathbf{Y}$" style="width:10px;height:8px;"> and the description of the dynamical system (1), the aim is to estimate both state variables <img src="dynamic_causal_modeling_m_eq03397130480831257552.png" alt="$\mathbf{X}$" style="width:9px;height:8px;"> and parameters <img src="dynamic_causal_modeling_m_eq14439582888765908571.png" alt="$\mathbf\theta$" style="width:5px;height:8px;">.</p><p>We consider only dynamical systems that are _*locally linear _*with respect to ODE parameters <img src="dynamic_causal_modeling_m_eq14439582888765908571.png" alt="$\mathbf\theta$" style="width:5px;height:8px;"> and individual states <img src="dynamic_causal_modeling_m_eq08291690262771002032.png" alt="$\mathbf{x}$" style="width:7px;height:5px;">. Such ODEs include mass-action kinetics and are given by:</p><p><img src="dynamic_causal_modeling_m_eq07431399494256856402.png" alt="$f_{k}(\mathbf{x}(t),\theta) = \sum_{i=1} \theta_{ki} \prod_{j \in\mathcal{M}_{ki}} x_j \qquad (2)$" style="width:185px;height:13px;">,</p><p>with $\mathcal{M}_{ki} \subseteq \{ 1, \dots, K\}$describing the state variables in each factor of the equation (i.e. the functions are linear in parameters and contain arbitrary large products of monomials of the states).</p><h2 id="19">Simulate Trajectories</h2><pre class="codeinput">non_diverging_trajectories = false; i = 0;
<span class="keyword">while</span> ~non_diverging_trajectories
</pre><p></p><div><ul><li><b>Sample ODE parameters</b></li></ul></div><pre>           non-selfinhibitory neuronal couplings (sampled uniformily in
the interval [-0.8,0.8];</pre><pre class="codeinput">    simulation.ode_param = -0.8 + (0.8-(-0.8)) * rand(1,length(symbols.param));
</pre><pre>           self-inhibitory neuronal couplings set to -1.</pre><pre class="codeinput">    simulation.ode_param(end-2:end) = -1;
</pre><p></p><div><ul><li><b>Numerical integration</b></li></ul></div><pre class="codeinput">    <span class="keyword">try</span>
        simulation_old = simulation;
        [simulation,obs_to_state_relation,fig_handle,plot_handle] = simulate_state_dynamics_dcm(simulation,symbols,ode,time,plot_settings,state.ext_input,<span class="string">'plot'</span>);
        non_diverging_trajectories = 1;
    <span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="dynamic_causal_modeling_m_01.png" style="width:1600px;height:800px;" alt=""> <pre class="codeinput"><span class="keyword">end</span>
</pre><p>start timer</p><pre class="codeinput">tic;
</pre><h2 id="28">Prior on States and State Derivatives</h2><p>Gradient matching with Gaussian processes assumes a joint Gaussian process prior on states and their derivatives:</p><p><img src="dynamic_causal_modeling_m_eq05949065962534761140.png" alt="$\left(\begin{array}{c} \mathbf{X} \\ \dot{\mathbf{X}} \end{array}\right) \sim \mathcal{N} \left(\begin{array}{c} \mathbf{X} \\ \dot{\mathbf{X}} \end{array}~;~\begin{array}{c} \mathbf{0} \\\mathbf{0} \end{array}~,~\begin{array}{cc} \mathbf{C}_{\phi} &amp; \mathbf{C}_{\phi}' \\ '\mathbf{C}_{\phi} &amp; \mathbf{C}_{\phi}'' \end{array} \right) \qquad (3)$" style="width:231px;height:28px;">,</p><p>with</p><p><img src="dynamic_causal_modeling_m_eq06131563045232954702.png" alt="$\mathrm{cov}(x_k(t), x_k(t)) = C_{\mathbf\phi_k}(t,t')$" style="width:131px;height:12px;">,</p><p><img src="dynamic_causal_modeling_m_eq09524647897482425600.png" alt="$\mathrm{cov}(\dot{x}_k(t), x_k(t)) = \frac{\partial C_{\mathbf{\phi}_k}(t,t')}{\partial t} =: C_{{\mathbf\phi}_k}'(t,t')$" style="width:185px;height:18px;">,</p><p><img src="dynamic_causal_modeling_m_eq09454301398506501108.png" alt="$\mathrm{cov}(x_k(t), \dot{x}_k(t)) = \frac{\partial C_{\mathbf\phi_k}(t,t')}{\partial t'} =: {'C_{\mathbf\phi_k}(t,t')}$" style="width:187px;height:17px;">,</p><p>$\mathrm{cov}(\dot{x}_k(t), \dot{x}_k(t)) = \frac{\partialC_{\mathbf\phi_k}(t,t') }{\partial t \partial t'} =: C_{\mathbf\phi_k}''(t,t')$.</p><pre class="error">Error updating Text.

 Character vector must have valid interpreter syntax: 
$\mathrm{cov}(\dot{x}_k(t), \dot{x}_k(t)) = \frac{\partialC_{\mathbf\phi_k}(t,t') }{\partial t \partial t'} =: C_{\mathbf\phi_k}''(t,t')$
</pre><h2 id="29">Matching Gradients</h2><p>Given the joint distribution over states and their derivatives (3) as well as the ODEs (2), we therefore have two expressions for the state derivatives:</p><p><img src="dynamic_causal_modeling_m_eq09779102347269268548.png" alt="$\dot{\mathbf{X}} = \mathbf{F} + \mathbf\epsilon_1, \mathbf\epsilon_1 \sim\mathcal{N}\left(\mathbf\epsilon_1;\mathbf{0}, \mathbf{I}\gamma \right)$" style="width:139px;height:13px;">,</p><p><img src="dynamic_causal_modeling_m_eq05510249786246633402.png" alt="$\dot{\mathbf{X}} = {'\mathbf{C}_{\phi}} \mathbf{C}_{\phi}^{-1}~\mathbf{X} + \mathbf\epsilon_2, \mathbf\epsilon_2 \sim\mathcal{N}\left(\mathbf\epsilon_2;\mathbf{0}, \mathbf{A} \right)$" style="width:179px;height:16px;">,</p><p>where <img src="dynamic_causal_modeling_m_eq00445188712889927684.png" alt="$\mathbf{F} := \mathbf{f}(\mathbf{X},\mathbf\theta)$" style="width:58px;height:11px;"> and <img src="dynamic_causal_modeling_m_eq06389346718055591683.png" alt="$\mathbf{A} :=\mathbf{C}_{\phi}'' -  {'\mathbf{C}_{\phi}} \mathbf{C}_{\phi}^{-1}\mathbf{C}_{\phi}'$" style="width:105px;height:15px;"> and <img src="dynamic_causal_modeling_m_eq17096441642737911057.png" alt="$\gamma$" style="width:6px;height:8px;"> is the error variance in the ODEs. Note that, in a deterministic system, the output of the ODEs <img src="dynamic_causal_modeling_m_eq10805855639155619100.png" alt="$\mathbf{F}$" style="width:8px;height:8px;"> should equal the state derivatives <img src="dynamic_causal_modeling_m_eq07315144976585928416.png" alt="$\dot{\mathbf{X}}$" style="width:9px;height:11px;">. However, in the first equation above we relax this contraint by adding stochasticity to the state derivatives <img src="dynamic_causal_modeling_m_eq07315144976585928416.png" alt="$\dot{\mathbf{X}}$" style="width:9px;height:11px;"> in order to compensate for a</p><p>potential model mismatch. The second equation above is obtained by deriving the conditional distribution for <img src="dynamic_causal_modeling_m_eq07315144976585928416.png" alt="$\dot{\mathbf{X}}$" style="width:9px;height:11px;"> from the joint distribution in equation (3). Equating the two expressions in the equations above we can eliminate the unknown state derivatives $\dot{\mathbf{X}$:</p><pre class="error">Error updating Text.

 Character vector must have valid interpreter syntax: 
$\dot{\mathbf{X}$
</pre><p><img src="dynamic_causal_modeling_m_eq11544247356856033682.png" alt="$\mathbf{F} = {'\mathbf{C}_{\phi}} \mathbf{C}_{\phi}^{-1} ~\mathbf{X} +\mathbf\epsilon_0 \qquad (4)$" style="width:130px;height:15px;">,</p><p>with <img src="dynamic_causal_modeling_m_eq15084253510815290366.png" alt="$\mathbf{\epsilon_0} := \mathbf{\epsilon_2} - \mathbf{\epsilon_1}$" style="width:58px;height:7px;">.</p><pre class="codeinput">[dC_times_invC,inv_C,A_plus_gamma_inv] = kernel_function(kernel,state,time.est);
</pre><h2 id="32">Rewrite ODEs as Linear Combination in Parameters</h2><p>Since, according to the mass action dynamics (equation 2), the ODEs are <i>*linear in the parameters *</i>$\mathbf\theta$ we can rewrite the ODEs in equation (2) as a linear combination in the parameters:</p><p><img src="dynamic_causal_modeling_m_eq14681271264105480906.png" alt="$\mathbf{B}_{\mathbf{\theta} k} \mathbf{\theta} + \mathbf{b}_{\mathbf{\theta} k} \stackrel{!}{=}\mathbf{f}_k(\mathbf{X},\mathbf{\theta}) \qquad (5)$" style="width:139px;height:15px;">,</p><p>where matrices <img src="dynamic_causal_modeling_m_eq14537279257693498981.png" alt="$\mathbf{B}_{\mathbf{\theta} k}$" style="width:17px;height:10px;"> and <img src="dynamic_causal_modeling_m_eq04855563019719143218.png" alt="$\mathbf{b}_{\mathbf{\theta} k}$" style="width:15px;height:10px;"> are defined such that the ODEs <img src="dynamic_causal_modeling_m_eq14967653859658475783.png" alt="$\mathbf{f}_k(\mathbf{X},\mathbf{\theta})$" style="width:36px;height:11px;"> are expressed as a linear combination in <img src="dynamic_causal_modeling_m_eq00000731545789844591.png" alt="$\mathbf{\theta}$" style="width:5px;height:8px;">.</p><pre class="codeinput">[ode_param.lin_comb.B,ode_param.lin_comb.b] = rewrite_odes_as_linear_combination_in_parameters(ode,symbols);
</pre><h2 id="35">Posterior over ODE Parameters</h2><p>Inserting (5) into (4) and solving for <img src="dynamic_causal_modeling_m_eq06840717269413420654.png" alt="$$\mathbf{\theta}$" style="width:5px;height:8px;">$ yields:</p><p><img src="dynamic_causal_modeling_m_eq14707740594757803178.png" alt="$\mathbf{\theta} = \mathbf{B}_{\mathbf{\theta}}^+ \left( {'\mathbf{C}_{\mathbf{\phi}}}\mathbf{C}_{\mathbf{\phi}}^{-1} \mathbf{X} - \mathbf{b}_{\mathbf{\theta}} + \mathbf{\epsilon_0}\right)$" style="width:143px;height:20px;">,</p><p>where <img src="dynamic_causal_modeling_m_eq05803544219715308982.png" alt="$\mathbf{B}_{\mathbf{\theta}}^+$" style="width:15px;height:13px;"> denotes the pseudo-inverse of <img src="dynamic_causal_modeling_m_eq17686033574112270987.png" alt="$\mathbf{B}_{\mathbf{\theta}}$" style="width:13px;height:10px;">. Since <img src="dynamic_causal_modeling_m_eq12476492725851578267.png" alt="$$\mathbf{C}_{\mathbf{\phi}}$" style="width:14px;height:11px;">$ is block diagonal we can rewrite the expression above as:</p><p><img src="dynamic_causal_modeling_m_eq07476366998092137637.png" alt="$\mathbf{\theta} = \left( \mathbf{B}_{\mathbf{\theta}}^T \mathbf{B}_{\mathbf{\theta}} \right)^{-1} ~\mathbf{B}_{\mathbf{\theta}}^T  \left( \sum_k {'\mathbf{C}_{\mathbf{\phi}_k}}\mathbf{C}_{\mathbf{\phi}_k}^{-1} \mathbf{X}_k - \mathbf{b}_{\mathbf{\theta} k} + \mathbf{\epsilon_0}^{(k)} \right)\\ ~= \left( \mathbf{B}_{\mathbf{\theta}}^T \mathbf{B}_{\mathbf{\theta}} \right)^{-1} \left(\sum_k \mathbf{B}_{\mathbf{\theta} k}^T \left( {'\mathbf{C}_{\mathbf{\phi}_k}}\mathbf{C}_{\mathbf{\phi}_k}^{-1} \mathbf{X}_k - \mathbf{b}_{\mathbf{\theta} k} +\mathbf{\epsilon_0}^{(k)} \right) \right)$" style="width:491px;height:20px;">,</p><p>where we subsitute the Moore-Penrose inverse for the pseudo-inverse (i.e. <img src="dynamic_causal_modeling_m_eq09091945040404351953.png" alt="$\mathbf{B}_{\mathbf{\theta}}^+ := \left( \mathbf{B}_{\mathbf{\theta}}^T \mathbf{B}_{\mathbf{\theta}}\right)^{-1} \mathbf{B}_{\mathbf{\theta}}^T$" style="width:99px;height:16px;">). We can therefore derive the posterior distribution over ODE parameters:</p><p>$p(\mathbf{\theta} \mid \mathbf{X}, \mathbf{\phi}, \gamma) = \mathcal{N}\left(\mathbf{\theta} ; \left( \mathbf{B}_{\mathbf{\theta}}^T\mathbf{B}_{\mathbf{\theta}} \right)^{-1} \left( \sum_k \mathbf{B}_{\mathbf{\theta} k}^T ~\left( {'\mathbf{C}_{\mathbf{\phi} k}} \mathbf{C}_{\mathbf{\phi} k}^{-1} \mathbf{X}_k -\mathbf{b}_{\mathbf{\theta} k} \right) \right), ~ \mathbf{B}_{\mathbf{\theta}}^+ ~(\mathbf{A} + \mathbf{I}\gamma) ~ \mathbf{B}_{\mathbf{\theta}}^{+T} \qquad (6)$.</p><pre class="error">Error updating Text.

 Character vector must have valid interpreter syntax: 
$p(\mathbf{\theta} \mid \mathbf{X}, \mathbf{\phi}, \gamma) = \mathcal{N}\left(\mathbf{\theta} ; \left( \mathbf{B}_{\mathbf{\theta}}^T\mathbf{B}_{\mathbf{\theta}} \right)^{-1} \left( \sum_k \mathbf{B}_{\mathbf{\theta} k}^T ~\left( {'\mathbf{C}_{\mathbf{\phi} k}} \mathbf{C}_{\mathbf{\phi} k}^{-1} \mathbf{X}_k -\mathbf{b}_{\mathbf{\theta} k} \right) \right), ~ \mathbf{B}_{\mathbf{\theta}}^+ ~(\mathbf{A} + \mathbf{I}\gamma) ~ \mathbf{B}_{\mathbf{\theta}}^{+T} \qquad (6)$
</pre><h2 id="37">Rewrite Hemodynamic ODEs as Linear Combination in (monotonic functions of) Individual Hemodynamic States</h2><div><ul><li>*Deoxyhemoglobin content *</li></ul></div><pre>               Rewrite the BOLD signal change equation as a linear combination
in a monotonic function of the deoxyhemoglobin content $$\exp(\mathbf{q})$$:</pre><pre>               $$\mathbf{R}_{q~\mathbf\lambda} ~ \exp(\mathbf{q}) ~+ ~
\mathbf{r}_{v~\mathbf\lambda} \stackrel{!}{=} ~\mathbf\lambda(\mathbf{q},\mathbf{v})$$.</pre><pre class="codeinput">         [state.deoxyhemo.R,state.deoxyhemo.r] = rewrite_bold_signal_eqn_as_linear_combination_in_deoxyhemo(symbols);
</pre><p></p><div><ul><li><b>Blood volume</b></li></ul></div><pre>               Rewrite the deoxyhemoglobin content ODE as a linear combination
in a monotonic function of the blood volume $\exp\left( 17 / 8 ~\mathbf{v}\right)$:</pre><pre>                $\mathbf{R}_{v\dot{q}} ~\exp\left( 17 / 8 ~\mathbf{v}\right)
~+~ \mathbf{r}_{v\dot{q}} \stackrel{!}{=} \mathbf{f}_{\dot{q}}(\mathbf{X},\mathbf\theta)$.</pre><pre class="codeinput">         [state.vol.R,state.vol.r] = rewrite_deoxyhemo_ODE_as_linear_combination_in_vol(ode,symbols);
</pre><p></p><div><ul><li><b>Blood flow</b></li></ul></div><pre>               Rewrite the blood volume ODE as a linear combination in
a monotonic function of the blood flow $\exp(\mathbf{f})$.</pre><pre>                  $$\mathbf{R}_{f~\dot{v}} ~ \exp(\mathbf{f}) + \mathbf{r}_{f~\dot{v}}
\stackrel{!}{=} \mathbf{f}_{\dot{v}}(\mathbf{X},\mathbf\theta)$$.</pre><pre class="codeinput">        [state.flow.R,state.flow.r] = rewrite_vol_ODE_as_linear_combination_in_flow(ode,symbols);
</pre><div><ul><li><b>Vasosignalling</b></li></ul></div><pre>               Rewrite the blood flow and vasoginalling ODEs as a linear
combination in vasosignalling $\mathbf{s}$.</pre><pre>                   $$\mathbf{R}_{s\dot{f}} ~\mathbf{s} + \mathbf{r}_{s\dot{f}}
\stackrel{!}{=} \mathbf{f}_{\dot{f}}(\mathbf{X},\mathbf\theta)$$.</pre><pre>                   $$\mathbf{R}_{s\dot{s}}~ \mathbf{s} + \mathbf{r}_{s\dot{s}}
\stackrel{!}{=} \mathbf{f}_{\dot{s}}(\mathbf{X},\mathbf\theta)$$.</pre><pre class="codeinput">         [state.vaso.R,state.vaso.r] = rewrite_vaso_and_flow_odes_as_linear_combination_in_vaso(ode,symbols);
</pre><h2 id="43">Rewrite Neuronal ODEs as Linear Combination in Individual Neuronal States</h2><p>We rewrite the ODE(s) <img src="dynamic_causal_modeling_m_eq17272354180476598168.png" alt="$$\mathbf{f}_k(\mathbf{X},\mathbf\theta)$" style="width:36px;height:11px;">$ as a linear combination in the individual state <img src="dynamic_causal_modeling_m_eq14184866443374303203.png" alt="$$\mathbf{n}_u$" style="width:11px;height:7px;">$:</p><pre>       $$\mathbf{R}_{uk}  \mathbf{n}_u + \mathbf{r}_{uk} \stackrel{!}{=}
\mathbf{f}_{k}(\mathbf{X},\mathbf\theta)$$,</pre><p>where matrices <img src="dynamic_causal_modeling_m_eq11473846968764703117.png" alt="$$\mathbf{R}_{uk}$" style="width:18px;height:10px;">$ and <img src="dynamic_causal_modeling_m_eq02299362643576640155.png" alt="$\mathbf{r}_{uk}$" style="width:14px;height:7px;"> are defined such that the ODE <img src="dynamic_causal_modeling_m_eq17272354180476598168.png" alt="$$\mathbf{f}_k(\mathbf{X},\mathbf\theta)$" style="width:36px;height:11px;">$ is expressed as a linear combination in the individual state <img src="dynamic_causal_modeling_m_eq14184866443374303203.png" alt="$$\mathbf{n}_u$" style="width:11px;height:7px;">$.</p><pre class="codeinput">[state.neuronal.R,state.neuronal.r] = rewrite_odes_as_linear_combination_in_ind_neuronal_states(ode,symbols,coupling_idx.states);
</pre><h2 id="46">Posterior over Individual States</h2><p>Given the linear combination of the ODEs w.r.t. an individual state, we define the matrices <img src="dynamic_causal_modeling_m_eq11780124863314593273.png" alt="$\mathbf{B}_u$" style="width:13px;height:10px;"> and <img src="dynamic_causal_modeling_m_eq15590211095018081680.png" alt="$\mathbf{b}_u$" style="width:11px;height:10px;"> such that the expression <img src="dynamic_causal_modeling_m_eq15941870326266439714.png" alt="$$\mathbf{f}(\mathbf{X},\mathbf{\theta}) - {'\mathbf{C}}_{\mathbf{\phi}}\mathbf{C}_{\mathbf{\phi}}^{-1} \mathbf{X}$" style="width:93px;height:15px;">$ is rewritten as a linear combination in an individual state <img src="dynamic_causal_modeling_m_eq00398522576481313565.png" alt="$\mathbf{x}_u$" style="width:11px;height:7px;">:</p><p><img src="dynamic_causal_modeling_m_eq08018014595476126940.png" alt="$\mathbf{B}_{u} \mathbf{x}_u + \mathbf{b}_{u} \stackrel{!}{=}\mathbf{f}(\mathbf{X},\mathbf{\theta}) - {'\mathbf{C}}_{\mathbf{\phi}}\mathbf{C}_{\mathbf{\phi}}^{-1} \mathbf{X} \qquad (7)$" style="width:194px;height:17px;">.</p><p>Inserting (7) into (4) and solving for <img src="dynamic_causal_modeling_m_eq06172288676100169704.png" alt="$$\mathbf{x}_u$" style="width:11px;height:7px;">$ yields:</p><p><img src="dynamic_causal_modeling_m_eq04934047781206375234.png" alt="$$\mathbf{x}_u = \mathbf{B}_{u}^+ \left( \mathbf{\epsilon_0} -\mathbf{b}_{u}\right)$" style="width:86px;height:13px;">$,</p><p>where <img src="dynamic_causal_modeling_m_eq00687478806446939535.png" alt="$$\mathbf{B}_{u}^+$" style="width:15px;height:13px;">$ denotes the pseudo-inverse of <img src="dynamic_causal_modeling_m_eq05698187735710752536.png" alt="$$\mathbf{B}_{u}$" style="width:13px;height:10px;">$. Since <img src="dynamic_causal_modeling_m_eq12476492725851578267.png" alt="$$\mathbf{C}_{\mathbf{\phi}}$" style="width:14px;height:11px;">$ is block diagonal we can rewrite the expression above as:</p><p><img src="dynamic_causal_modeling_m_eq05588656242432596112.png" alt="$\mathbf{x}_u = \left( \mathbf{B}_{u} \mathbf{B}_{u}^T \right)^{-1}\mathbf{B}_{u}^T \sum_k \left(\mathbf{\epsilon_0}^{(k)} -\mathbf{b}_{uk} \right)\\ \quad= \left( \mathbf{B}_{u} \mathbf{B}_{u}^T \right)^{-1} \sum_k\mathbf{B}_{uk}^T \left(\mathbf{\epsilon_0}^{(k)} -\mathbf{b}_{uk} \right)$" style="width:349px;height:16px;">,</p><p>where we subsitute the Moore-Penrose inverse for the pseudo-inverse (i.e. <img src="dynamic_causal_modeling_m_eq09091945040404351953.png" alt="$\mathbf{B}_{\mathbf{\theta}}^+ := \left( \mathbf{B}_{\mathbf{\theta}}^T \mathbf{B}_{\mathbf{\theta}}\right)^{-1} \mathbf{B}_{\mathbf{\theta}}^T$" style="width:99px;height:16px;">).  We can therefore derive the posterior distribution over an individual state <img src="dynamic_causal_modeling_m_eq01182610398367661295.png" alt="$$\mathbf{x}_{u}$" style="width:11px;height:7px;">$:</p><p><img src="dynamic_causal_modeling_m_eq14053813124642092754.png" alt="$p(\mathbf{x}_u \mid \mathbf{X}_{-u}, \mathbf{\phi}, \gamma)= \mathcal{N}\left(\mathbf{x}_u ; \left( \mathbf{B}_{u} \mathbf{B}_{u}^T\right)^{-1} \left( - \sum_k \mathbf{B}_{uk}^T \mathbf{b}_{uk} \right),~\mathbf{B}_{u}^{+} ~ (\mathbf{A} + \mathbf{I}\gamma) ~ \mathbf{B}_u^{+T}\right) \qquad (8)$" style="width:394px;height:20px;">,</p><p>with <img src="dynamic_causal_modeling_m_eq09393849726171219045.png" alt="$$\mathbf{X}_{-u}$" style="width:20px;height:10px;">$ denoting the set of all states except state <img src="dynamic_causal_modeling_m_eq06172288676100169704.png" alt="$$\mathbf{x}_u$" style="width:11px;height:7px;">$.</p><h2 id="48">Mean-field Variational Inference</h2><p>To infer the parameters <img src="dynamic_causal_modeling_m_eq06840717269413420654.png" alt="$$\mathbf{\theta}$" style="width:5px;height:8px;">$, we want to find the maximum a posteriori estimate (MAP):</p><p><img src="dynamic_causal_modeling_m_eq13511049836739271940.png" alt="$\mathbf{\theta}^* := \mathrm{arg} \max_{\mathbf{\theta}} ~ \ln p(\mathbf{\theta} \mid\mathbf{Y},\mathbf{\phi},\gamma,\mathbf \sigma)\\ \quad= \mathrm{arg}\max_{\mathbf{\theta}} ~ \ln \int  p(\mathbf{\theta},\mathbf{X} \mid\mathbf{Y},\mathbf{\phi},\gamma,\mathbf\sigma) d\mathbf{X}\\ \quad= \mathrm{arg}\max_{\mathbf{\theta}} ~ \ln \int p(\mathbf{\theta} \mid \mathbf{X},\mathbf{\phi},\gamma)p(\mathbf{X} \mid \mathbf{Y}, \mathbf{\phi},\mathbf\sigma) d\mathbf{X} \qquad(9)$" style="width:631px;height:13px;">.</p><p>However, the integral above is intractable due to the strong couplings induced by the nonlinear ODEs <img src="dynamic_causal_modeling_m_eq07966868336018839913.png" alt="$$\mathbf{f}$" style="width:5px;height:8px;">$ which appear in the term <img src="dynamic_causal_modeling_m_eq15455916038640034804.png" alt="$$p(\mathbf{\theta} \mid \mathbf{X},\mathbf{\phi},\gamma)$" style="width:60px;height:11px;">$.</p><p>We use mean-field variational inference to establish variational lower bounds that are analytically tractable by decoupling state variables from the ODE parameters as well as decoupling the state variables from each other. Note that, since the ODEs described by equation (2) are <i>*locally linear</i>*, both conditional distributions <img src="dynamic_causal_modeling_m_eq04257617213050957075.png" alt="$$p(\mathbf{\theta} \mid\mathbf{X},\mathbf{Y},\mathbf{\phi},\gamma,\mathbf\sigma)$" style="width:87px;height:11px;">$ (equation (6)) and <img src="dynamic_causal_modeling_m_eq02707094767016802694.png" alt="$$p(\mathbf{x}_u \mid \mathbf{\theta},\mathbf{X}_{-u},\mathbf{Y},\mathbf{\phi},\gamma,\mathbf\sigma)$" style="width:114px;height:11px;">$ (equation (8)) are analytically tractable and Gaussian distributed as mentioned previously. The decoupling is induced by designing a variational distribution <img src="dynamic_causal_modeling_m_eq04524928483400281720.png" alt="$$Q(\mathbf{\theta},\mathbf{X})$" style="width:36px;height:11px;">$ which is restricted to the family of factorial distributions:</p><p><img src="dynamic_causal_modeling_m_eq07116708179068120352.png" alt="$$\mathcal{Q} := \bigg{\{} Q : Q(\mathbf{\theta},\mathbf{X}) = q(\mathbf{\theta}) \prod_uq(\mathbf{x}_u) \bigg{\}}$" style="width:173px;height:29px;">$.</p><p>The particular form of <img src="dynamic_causal_modeling_m_eq08886706959074116312.png" alt="$$q(\mathbf{\theta})$" style="width:19px;height:11px;">$ and <img src="dynamic_causal_modeling_m_eq17420406007066013322.png" alt="$$q(\mathbf{x}_u)$" style="width:25px;height:11px;">$ are designed to be Gaussian distributed which places them in the same family as the true full conditional distributions. To find the optimal factorial distribution we minimize the Kullback-Leibler divergence between the variational and the true posterior distribution:</p><p><img src="dynamic_causal_modeling_m_eq00221060080535114208.png" alt="$$\hat{Q} := \mathrm{arg} \min_{Q(\mathbf{\theta},\mathbf{X}) \in \mathcal{Q}} \mathrm{KL}\left[ Q(\mathbf{\theta},\mathbf{X}) \mid \mid p(\mathbf{\theta},\mathbf{X} \mid\mathbf{Y},\mathbf{\phi}, \gamma,\mathbf\mathbf{\sigma}) \right] \qquad (10)$" style="width:284px;height:21px;">$,</p><p>where <img src="dynamic_causal_modeling_m_eq15743246986648076931.png" alt="$$\hat{Q}$" style="width:8px;height:13px;">$ is the proxy distribution. The proxy distribution that minimizes the KL-divergence (10) depends on the true full conditionals and is given by:</p><p><img src="dynamic_causal_modeling_m_eq00524040698376027693.png" alt="$\hat{q}({\mathbf{\theta}}) \propto \exp \left(~ E_{Q_{-\mathbf{\theta}}} \ln p(\mathbf{\theta} \mid\mathbf{X},\mathbf{Y},\mathbf{\phi},\gamma,\mathbf\mathbf{\sigma}) ~\right) \qquad (11)\\\hat{q}(\mathbf{x}_u) \propto \exp\left( ~ E_{Q_{-u}} \ln p(\mathbf{x}_u\mid \mathbf{\theta}, \mathbf{X}_{-u},\mathbf{Y},\mathbf{\phi},\gamma,\mathbf{\sigma}) ~ \right)\qquad (12)$" style="width:502px;height:12px;">.</p><h2 id="51">Denoising BOLD Observations</h2><p>We denoise the BOLD observation by standard GP regression.</p><pre class="codeinput">bold_response.denoised_obs = denoising_BOLD_observations(simulation.bold_response{:,{<span class="string">'n_1'</span>,<span class="string">'n_3'</span>,<span class="string">'n_2'</span>}},inv_C,symbols,simulation);
</pre><h2 id="55">Fitting observations of state trajectories</h2><p>We fit the observations of state trajectories by standard GP regression. The data-informed distribution$ <img src="dynamic_causal_modeling_m_eq00607084938701956025.png" alt="$p(\mathbf{X} \mid \mathbf{Y}, \mathbf{\phi},\mathbf\mathbf{\sigma})$" style="width:65px;height:11px;">$ in euqation (9) can be determined analytically using Gaussian process regression with the GP prior <img src="dynamic_causal_modeling_m_eq03361668991287687922.png" alt="$$p(\mathbf{X} \mid\mathbf{\phi}) = \prod_k \mathcal{N}(\mathbf{x}_k ;\mathbf{0},\mathbf{C}_{\mathbf{\phi}})$" style="width:130px;height:24px;">$:</p><p><img src="dynamic_causal_modeling_m_eq07752023364341374350.png" alt="$$p(\mathbf{X} \mid \mathbf{Y}, \mathbf{\phi},\gamma) = \prod_k\mathcal{N}(\mathbf{x}_k ;\mathbf\mu_k(\mathbf{y}_k),\mathbf\mathbf{\sigma}_k)$" style="width:178px;height:24px;">$,</p><p>where <img src="dynamic_causal_modeling_m_eq05139699893116141298.png" alt="$$\mathbf\mu_k(\mathbf{y}_k) := \mathbf{\sigma}_k^{-2} \left(\mathbf{\sigma}_k^{-2}\mathbf{I} + \mathbf{C}_{\mathbf{\phi}_k}^{-1} \right)^{-1} \mathbf{y}_k$" style="width:159px;height:23px;">$ and <img src="dynamic_causal_modeling_m_eq02647485491785378212.png" alt="$$\mathbf{\sigma}_k ^{-1}:=\mathbf{\sigma}_k^{-2} \mathbf{I} +\mathbf{C}_{\mathbf\mathbf{\phi}_k}^{-1}$" style="width:89px;height:15px;">$.</p><pre class="codeinput">[mu,inv_sigma] = fitting_state_observations(inv_C,obs_to_state_relation,simulation,symbols);
</pre><h2 id="58">Coordinate Ascent Variational Gradient Matching</h2><p>We minimize the KL-divergence in equation (10) by coordinate descent (where each step is analytically tractable) by iterating between determining the proxy for the distribution over ODE parameters <img src="dynamic_causal_modeling_m_eq13317601314667608785.png" alt="$$\hat{q}(\mathbf{\theta})$" style="width:19px;height:11px;">$ and the proxies for the distribution over individual states <img src="dynamic_causal_modeling_m_eq11393795473504476532.png" alt="$$\hat{q}(\mathbf{x}_u)$" style="width:25px;height:11px;">$.</p><div><ul><li><b>Initialize the state estimation by the GP regression posterior</b></li></ul></div><pre class="codeinput">            state.proxy.mean = array2table([time.est',mu],<span class="string">'VariableNames'</span>,[<span class="string">'time'</span>,symbols.state_string]);
            bold_response.obs_old = bold_response.denoised_obs;
            ode_param.proxy.mean = zeros(length(symbols.param),1);
</pre><p></p><div><ul><li><b>Coordinate ascent</b></li></ul></div><pre class="codeinput">            <span class="keyword">for</span> i = 1:opt_settings.coord_ascent_numb_iter
</pre><h2 id="61">*                           *</h2><h2 id="62"><b>Intercept due to Confounding Effects</b></h2><p>The intercept is determined by a minimum least squares estimator:</p><p><img src="dynamic_causal_modeling_m_eq08133032823123248372.png" alt="$\mathbf{X} \hat{\beta} := \mathbf{X} ( \mathbf{X}^T \mathbf{X} )^{-1} \mathbf{X}^T (\mathbf{y} - \mathbf{\lambda}(\mathbf{q},\mathbf{v}))$" style="width:165px;height:14px;">.</p><pre>               bold_response_signal_change = bold_signal_change_eqn(state.proxy.mean{:,'v_1','v_2','v_3'},...
                   state.proxy.mean{:,'q_1','q_2','q_3'});
               bold_response.confounding_effects.intercept = determine_intercept(bold_response.obs_old-bold_response_signal_change,...
                   bold_response.confounding_effects.X0,bold_response.confounding_effects.X0_penrose_inv);</pre><pre class="codeinput">                bold_response.confounding_effects.intercept = zeros(height(simulation.bold_response),width(simulation.bold_response)-1);
                bold_response.denoised_obs = bold_response.obs_old - bold_response.confounding_effects.intercept;
</pre><h2 id="67">Proxy for Hemodynamic States</h2><p>Determine the proxies for the states, starting with deoxyhemoglobin followed by blood volume, blood flow and finally vasosignalling. The information flow in the hemodynamic system is shown in its factor graph below:</p><p>.</p><p>The model inversion in the hemodynmic factor graph above occurs locally w.r.t. individual states. Given the expression for the BOLD signal change equation, we invert the BOLD signal change equation analytically to determine the deoxyhemoglobin content <img src="dynamic_causal_modeling_m_eq00515664967115030090.png" alt="$$\mathbf{q}$" style="width:7px;height:8px;">$ (1). The newly inferred deoxyhemoglobin content <img src="dynamic_causal_modeling_m_eq00515664967115030090.png" alt="$$\mathbf{q}$" style="width:7px;height:8px;">$ influences the expression for the factor associated with the change in deoxyhemoglobin content <img src="dynamic_causal_modeling_m_eq13698666530012364155.png" alt="$$\mathbf{h}_{\dot{\mathbf{q}}}$" style="width:12px;height:11px;">$, which we subsequently invert analytically to infer the blood volume <img src="dynamic_causal_modeling_m_eq04401423582739758326.png" alt="$\mathbf{v}$" style="width:7px;height:6px;"> (2). Thereafter, we infer the blood flow <img src="dynamic_causal_modeling_m_eq07966868336018839913.png" alt="$$\mathbf{f}$" style="width:5px;height:8px;">$ (3) by inverting the factors associated with the change in blood volume <img src="dynamic_causal_modeling_m_eq06415322318788899516.png" alt="$$\mathbf{h}_{\dot{\mathbf{v}}}$" style="width:12px;height:10px;">$ as well as vasosignalling <img src="dynamic_causal_modeling_m_eq13413985719540132229.png" alt="$$\mathbf{h}_{\dot{\mathbf{s}}}$" style="width:10px;height:10px;">$, followed by inferring vasosignalling <img src="dynamic_causal_modeling_m_eq06544263557782508582.png" alt="$$\mathbf{s}$" style="width:5px;height:6px;">$ (4) by inverting the factors associated with blood flow induction <img src="dynamic_causal_modeling_m_eq18331623628987926341.png" alt="$$\mathbf{h}_{\dot{\mathbf{f}}}$" style="width:11px;height:11px;">$ and vasosignalling <img src="dynamic_causal_modeling_m_eq13413985719540132229.png" alt="$$\mathbf{h}_{\dot{\mathbf{s}}}$" style="width:10px;height:10px;">$. Finally, the neuronal dynamics (5) are learned, in part, by inverting the factor associated with vasosignalling <img src="dynamic_causal_modeling_m_eq13413985719540132229.png" alt="$$\mathbf{h}_{\dot{\mathbf{s}}}$" style="width:10px;height:10px;">$. The typical trajectories of each of the states are shown (red) together with their iterative approximation (grey lines) obtained by graphical DCM.</p><div><ul><li><b>Proxy for deoxyhemolgobin content</b></li></ul></div><pre>               Damping is required since we invert only the factor for
the BOLD signal change equation w.r.t. a monotonic function of deoxyhemoglobin
content $\exp( \mathbf{q})$.</pre><pre>                          * Undamped proxy:*</pre><pre class="codeinput">                state_proxy_undamped = proxy_for_deoxyhemoglobin_content(state.deoxyhemo,state.proxy.mean{:,symbols.state_string},<span class="keyword">...</span>
                    bold_response.denoised_obs,symbols,A_plus_gamma_inv,opt_settings);
</pre><pre>                          * Damped proxy:*</pre><pre class="codeinput">                state.proxy.mean{:,{<span class="string">'q_1'</span>,<span class="string">'q_3'</span>,<span class="string">'q_2'</span>}} = (1-opt_settings.damping) * state.proxy.mean{:,{<span class="string">'q_1'</span>,<span class="string">'q_3'</span>,<span class="string">'q_2'</span>}} + <span class="keyword">...</span>
                    opt_settings.damping * state_proxy_undamped;
</pre><div><ul><li><b>Proxy for blood volume</b></li></ul></div><div><ul><li>*    Damping is required since we invert only the a subset of ODEs w.r.t. a monotonic function of blood volume <img src="dynamic_causal_modeling_m_eq17496863592503124246.png" alt="$\exp\left( 17/ 8 ~ \mathbf{v} \right)$" style="width:59px;height:11px;">.</li></ul></div><div><ul><li>Undamped proxy:*</li></ul></div><pre class="codeinput">                state_proxy_undamped = proxy_for_blood_volume(state.vol,dC_times_invC,state.proxy.mean{:,symbols.state_string},<span class="keyword">...</span>
                    ode_param.proxy.mean,symbols,A_plus_gamma_inv,opt_settings);
</pre><pre>                           *Damped proxy:*</pre><pre class="codeinput">                state.proxy.mean{:,{<span class="string">'v_1'</span>,<span class="string">'v_3'</span>,<span class="string">'v_2'</span>}} = (1-opt_settings.damping) * state.proxy.mean{:,{<span class="string">'v_1'</span>,<span class="string">'v_3'</span>,<span class="string">'v_2'</span>}} + <span class="keyword">...</span>
                    opt_settings.damping * state_proxy_undamped;
</pre><p></p><div><ul><li><b>Proxy for blood flow</b></li></ul></div><pre>               Damping is required since we invert only the a subset of
ODEs w.r.t. a mononic function of blood flow $\exp(\mathbf{f})$.</pre><pre>                           *Undamped proxy:*</pre><pre class="codeinput">                state_proxy_undamped = proxy_for_blood_flow(state.flow,dC_times_invC,state.proxy.mean{:,symbols.state_string},<span class="keyword">...</span>
                    ode_param.proxy.mean,symbols,A_plus_gamma_inv,opt_settings);
</pre><pre>                           *Damped proxy:*</pre><pre class="codeinput">                state.proxy.mean{:,{<span class="string">'f_1'</span>,<span class="string">'f_3'</span>,<span class="string">'f_2'</span>}} = (1-opt_settings.damping) * state.proxy.mean{:,{<span class="string">'f_1'</span>,<span class="string">'f_3'</span>,<span class="string">'f_2'</span>}} + <span class="keyword">...</span>
                    opt_settings.damping * state_proxy_undamped;
</pre><p></p><div><ul><li><b>Proxy for vasosignalling</b></li></ul></div><pre>               No damping is required because we invert all ODEs w.r.t.
vasosingalling $\mathbf{s}$.</pre><pre class="codeinput">                state.proxy.mean{:,{<span class="string">'s_1'</span>,<span class="string">'s_3'</span>,<span class="string">'s_2'</span>}} = proxy_for_vasosignalling(state.vaso,dC_times_invC,<span class="keyword">...</span>
                    state.proxy.mean{:,symbols.state_string},ode_param.proxy.mean,symbols,A_plus_gamma_inv,opt_settings);
</pre><p></p><h2 id="76">Proxy for Neuronal States</h2><div><ul><li>*Determine the proxies for the neuronal states. An example of the information flow in the neuronal part of the nonlinear forward modulating (nonlin_fwd_mod) is shown in its factor graph below:</li></ul></div><p>.</p><pre>           In the neuronal factor graph (for the nonlinear forwad modulation)
above each individual state appears linear in every factor in the neuronal model.
We can therefore analytically invert every factor to determine the neuronal
state. The typical trajectories of each of the states are shown (red) together
with their iterative approximation (grey lines) obtained by variational gradient
matching.</pre><p>No damping is required because we invert all ODEs w.r.t. neuronal populations <img src="dynamic_causal_modeling_m_eq17512821799712548277.png" alt="$\mathbf{n}$" style="width:7px;height:5px;">.</p><pre class="codeinput">            state.proxy.mean{:,{<span class="string">'n_1'</span>,<span class="string">'n_3'</span>,<span class="string">'n_2'</span>}} = proxy_for_neuronal_populations(state.neuronal,<span class="keyword">...</span>
                state.proxy.mean{:,symbols.state_string},ode_param.proxy.mean',dC_times_invC,<span class="keyword">...</span>
                coupling_idx.states,symbols,A_plus_gamma_inv,opt_settings);
</pre><p></p><p><b>Keep initial value at zero</b></p><pre class="codeinput">            state_idx = cellfun(@(x) ~strcmp(x(1),<span class="string">'u'</span>),symbols.state_string);
            state.proxy.mean{1,state_idx} = bsxfun(@minus,state.proxy.mean{1,state_idx},state.proxy.mean{1,state_idx});
</pre><h2 id="79">*            *</h2><h2 id="80"></h2><h2 id="81"><b>Proxy for ODE parameters</b></h2><pre>                   Expanding the proxy distribution in equation (11) for
$$\mathbf{\theta}$$ yields:</pre><pre>                          $\hat{q}(\mathbf{\mathbf\theta}) \propto \exp
\left( ~E_{Q_{-\mathbf\theta}}     \ln p(\theta \mid \mathbf{X},\mathbf{Y},\mathbf\phi,\gamma,\mathbf\sigma)
~     \right) \\ \qquad= \exp \left( ~E_{Q_{-\mathbf{\theta}}} \ln \mathcal{N}\left(\mathbf{\theta}
; \left(    \mathbf{B}_{\mathbf{\theta}}^T \mathbf{B}_{\mathbf{\theta}} \right)^{-1}
\left( \sum_k    \mathbf{B}_{\mathbf{\theta} k}^T ~ \left( {'\mathbf{C}_{\mathbf{\phi}
k}}    \mathbf{C}_{\mathbf{\phi} k}^{-1} \mathbf{X}_k - \mathbf{b}_{\mathbf{\theta}
k} \right)    \right), ~ \mathbf{B}_{\mathbf{\theta}}^+ ~ (\mathbf{A} + \mathbf{I}\gamma)
~    \mathbf{B}_{\mathbf{\theta}}^{+T} \right) ~\right)$,</pre><pre>                   where we substitute $$p(\mathbf{\theta} \mid \mathbf{X},\mathbf{\phi},\gamma)$$
with its density given in equation (6).</pre><pre>                   No damping is required because we invert all ODEs w.r.t.
neuronal couplings $\mathbf{\theta}$.</pre><pre class="codeinput">            <span class="keyword">if</span> i&gt;200 || i==opt_settings.coord_ascent_numb_iter
                [ode_param.proxy.mean,ode_param.proxy.inv_cov] = proxy_for_ode_parameters(<span class="keyword">...</span>
                    state.proxy.mean{:,symbols.state_string},dC_times_invC,ode_param.lin_comb,<span class="keyword">...</span>
                    symbols,A_plus_gamma_inv,opt_settings);
            <span class="keyword">end</span>
</pre><pre class="codeinput">            <span class="keyword">if</span> i==1 || ~mod(i,20)
                plot_results(fig_handle,state,simulation,ode_param.proxy.mean,plot_handle,symbols,plot_settings,<span class="string">'not_final'</span>);
            <span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="dynamic_causal_modeling_m_02.png" style="width:1600px;height:800px;" alt=""> <img vspace="5" hspace="5" src="dynamic_causal_modeling_m_03.png" style="width:1600px;height:800px;" alt=""> <img vspace="5" hspace="5" src="dynamic_causal_modeling_m_04.png" style="width:1600px;height:800px;" alt=""> <img vspace="5" hspace="5" src="dynamic_causal_modeling_m_05.png" style="width:1600px;height:800px;" alt=""> <img vspace="5" hspace="5" src="dynamic_causal_modeling_m_06.png" style="width:1600px;height:800px;" alt=""> <img vspace="5" hspace="5" src="dynamic_causal_modeling_m_07.png" style="width:1600px;height:800px;" alt=""> <img vspace="5" hspace="5" src="dynamic_causal_modeling_m_08.png" style="width:1600px;height:800px;" alt=""> <img vspace="5" hspace="5" src="dynamic_causal_modeling_m_09.png" style="width:1600px;height:800px;" alt=""> <img vspace="5" hspace="5" src="dynamic_causal_modeling_m_10.png" style="width:1600px;height:800px;" alt=""> <img vspace="5" hspace="5" src="dynamic_causal_modeling_m_11.png" style="width:1600px;height:800px;" alt=""> <img vspace="5" hspace="5" src="dynamic_causal_modeling_m_12.png" style="width:1600px;height:800px;" alt=""> <p></p><pre class="codeinput"><span class="keyword">end</span>
</pre><h2 id="86"></h2><h2 id="87"></h2><h2 id="88"><b>Numerical Integration with Estimated ODE Parameters</b></h2><p>See whether we actually fit the BOLD responses well. Curves are shown in black.</p><pre class="codeinput">simulation2 = simulation_old; simulation2.ode_param = ode_param.proxy.mean';
[simulation2,obs_to_state_relation] = simulate_state_dynamics_dcm(simulation2,symbols,ode,time,<span class="keyword">...</span>
    plot_settings,state.ext_input,<span class="string">'no plot'</span>);
state.proxy.num_int = simulation2.state;
</pre><p></p><div><ul><li><b>Final result</b></li></ul></div><pre class="codeinput">            plot_results(fig_handle,state,simulation,ode_param.proxy.mean,plot_handle,symbols,plot_settings,<span class="string">'final'</span>);
</pre><img vspace="5" hspace="5" src="dynamic_causal_modeling_m_13.png" style="width:1600px;height:800px;" alt=""> <h2 id="92">Time Taken</h2><pre class="codeinput">disp([<span class="string">'time taken: '</span> num2str(toc) <span class="string">' seconds'</span>])
</pre><pre class="codeoutput">time taken: 80.5108 seconds
</pre><h2 id="95">References</h2><p>*Gorbach, N.S. , Bauer, S. *and Buhmann, J.M., Scalable Variational Inference for Dynamical Systems. 2017a. Neural Information Processing Systems (NIPS). Link to NIPS paper <a href="https://papers.nips.cc/paper/7066-scalable-variational-inference-for-dynamical-systems.pdf">here</a> and arxiv paper <a href="https://arxiv.org/abs/1705.07079">here</a>.</p><p><b>Bauer, S. , Gorbach, N.S.</b> and Buhmann, J.M., Efficient and Flexible Inference for Stochastic Differential Equations. 2017b. Neural Information Processing Systems (NIPS). Link to NIPS paper <a href="https://papers.nips.cc/paper/7274-efficient-and-flexible-inference-for-stochastic-systems.pdf">here</a>.</p><p>Wenk, P., Gotovos, A., Bauer, S., Gorbach, N.S., Krause, A. and Buhmann, J.M., Fast Gaussian Process Based Gradient Matching for Parameters Identification in Systems of Nonlinear ODEs. 2018. In submission to Conference on Uncertainty in Artificial Intelligence (UAI). Link to arxiv paper <a href="https://arxiv.org/pdf/1804.04378.pdf">here</a>.</p><p>Calderhead, B., Girolami, M. and Lawrence. N.D., 2002. Accelerating Bayesian inference over nonlinear differential equation models. In Advances in Neural Information Processing Systems (NIPS) . 22.</p><p>The authors in bold font have contributed equally to their respective papers.</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Variational Gradient Matching for Dynamical Systems: Dynamic Causal Modeling
%% ,
%% *Authors*: 
% *Nico Stephan Gorbach* and *Stefan Bauer*, email: nico.gorbach@gmail.com
% 
% 
%% Contents:
% Instructional code for the NIPS (2018) paper <https://papers.nips.cc/paper/7066-scalable-variational-inference-for-dynamical-systems.pdf 
% Scalable Variational Inference for Dynamical Systems> by Nico S. Gorbach, Stefan 
% Bauer and Joachim M. Buhmann. Please cite our paper if you use our program for 
% a further publication. Part of the derivation below is described in Wenk et 
% al. (2018). Example dynamical system used in this code:* Lorenz attractor* system 
% with the* y-dimension unobserved*. The ODE parameters are also unobserved.
% 
% 
% 
% 
% 
clear all; close all;
%% User Input: Simulation Settings
% * *Simulation ODEs*
%%
        simulation.odes = 'fwd_mod_driving';
%% 
% * *final time for simulation:*

        simulation.final_time = 359*3.22;
%% 
% * *observation noise:*

        simulation.state_obs_variance = @(x)(bsxfun(@rdivide,var(x),5));
%% 
% * *time interval between observations:*

        simulation.interval_between_observations = 0.1;
%% 
% **
%% User Input: Estimation
% * *Candidate ODEs*

        candidate_odes = 'fwd_mod_driving'; 
%% 
% * *Kernel*
% 
%                 Kernel parameters $\mathbf\phi$:

        kernel.param = [10,0.2];
%% 
% * *Error variance on state derivatives (i.e.* $\gamma$*)*:

        state.derivative_variance = 6.*ones(11-3,1);
%% 
% * *Estimation times*

        time.est = 0:3.22:359*3.22;       
%% 
% 
% 
% 
%% Preprocessing
% 

[symbols,simulation,ode,odes_path,coupling_idx,opt_settings,plot_settings,state] = preprocessing_dynamic_causal_modeling (simulation,candidate_odes,state);
%% 
% 
%% Mass Action Dynamical Systems
% 
% 
% A deterministic dynamical system is represented by a set of $K$ ordinary 
% differential equations (ODEs) with model parameters $\mathbf\theta \in \mathcal{R}^d$ 
% that describe the evolution of $K$ states $\mathbf{x}(t) = [x_1(t),\ldots, x_K(t)]^T$ 
% such that:  
% 
% $\dot{\mathbf{x}}(t) = \frac{d \mathbf{x}(t)}{d t} = \mathbf{f}(\mathbf{x}(t),\mathbf\theta) 
% \qquad (1)$,
% 
% A sequence of observations, $\mathbf{y}(t)$, is usually contaminated by 
% measurement error which we assume to be normally distributed with zero mean 
% and variance for each of the $K$ states, i.e. $\mathbf{E}\sim\mathcal{N}(\mathbf{E};\mathbf{0},\mathbf{D})$, 
% with $\mathbf{D}_{ik}=\sigma_k ^2 \delta_{ik}$. For $N$ distinct time points 
% the overall system may therefore be summarized as  
% 
% $\mathbf{Y} = \mathbf{X} + \mathbf{E}$,
% 
% where
% 
% $\mathbf{X} = [\mathbf{x}(t_1),\ldots,\mathbf{x}(t_N)] =  [\mathbf{x}_1,\ldots,\mathbf{x}_K]^T$,
% 
% $\mathbf{Y} = [\mathbf{y}(t_1),\ldots,\mathbf{y}(t_N)] =  [\mathbf{y}_1,\ldots,\mathbf{y}_K]^T$,
% 
% and $\mathbf{x}_k = [x_k(t_1),\ldots,x_k(t_N)]^T$ is the $k$'th state sequence 
% and $\mathbf{y}_k = [y_k(t_1),\ldots,y_k(t_N)]^T$ are the observations. Given 
% the observations $\mathbf{Y}$ and the description of the dynamical system (1), 
% the aim is to estimate both state variables $\mathbf{X}$ and parameters $\mathbf\theta$.
% 
% We consider only dynamical systems that are _*locally linear _*with respect 
% to ODE parameters $\mathbf\theta$ and individual states $\mathbf{x}$. Such ODEs 
% include mass-action kinetics and are given by:
% 
% $f_{k}(\mathbf{x}(t),\theta) = \sum_{i=1} \theta_{ki} \prod_{j \in\mathcal{M}_{ki}} 
% x_j \qquad (2)$,
% 
% with $\mathcal{M}_{ki} \subseteq \{ 1, \dots, K\}$describing the state 
% variables in each factor of the equation (i.e. the functions are linear in parameters 
% and contain arbitrary large products of monomials of the states).
%% 
% 
%% Simulate Trajectories
% 
%%
non_diverging_trajectories = false; i = 0;
while ~non_diverging_trajectories 
%% 
% **
% 
% * *Sample ODE parameters*
% 
%             non-selfinhibitory neuronal couplings (sampled uniformily in 
% the interval [-0.8,0.8];

    simulation.ode_param = -0.8 + (0.8-(-0.8)) * rand(1,length(symbols.param));  
%% 
%             
% 
%             self-inhibitory neuronal couplings set to -1.

    simulation.ode_param(end-2:end) = -1; 
%% 
% **
% 
% * *Numerical integration*

    try
        simulation_old = simulation;
        [simulation,obs_to_state_relation,fig_handle,plot_handle] = simulate_state_dynamics_dcm(simulation,symbols,ode,time,plot_settings,state.ext_input,'plot');
        non_diverging_trajectories = 1;
    end
end
%% 
% 
% 
% start timer
%%
tic;
%% 
% 
%% Prior on States and State Derivatives
% 
% 
% Gradient matching with Gaussian processes assumes a joint Gaussian process 
% prior on states and their derivatives:
% 
% $\left(\begin{array}{c} \mathbf{X} \\ \dot{\mathbf{X}} \end{array}\right) 
% \sim \mathcal{N} \left(\begin{array}{c} \mathbf{X} \\ \dot{\mathbf{X}} \end{array}~;~\begin{array}{c} 
% \mathbf{0} \\\mathbf{0} \end{array}~,~\begin{array}{cc} \mathbf{C}_{\phi} & 
% \mathbf{C}_{\phi}' \\ '\mathbf{C}_{\phi} & \mathbf{C}_{\phi}'' \end{array} \right) 
% \qquad (3)$,
% 
% with         
% 
% $\mathrm{cov}(x_k(t), x_k(t)) = C_{\mathbf\phi_k}(t,t')$, 
% 
% $\mathrm{cov}(\dot{x}_k(t), x_k(t)) = \frac{\partial C_{\mathbf{\phi}_k}(t,t')}{\partial 
% t} =: C_{{\mathbf\phi}_k}'(t,t')$, 
% 
% $\mathrm{cov}(x_k(t), \dot{x}_k(t)) = \frac{\partial C_{\mathbf\phi_k}(t,t')}{\partial 
% t'} =: {'C_{\mathbf\phi_k}(t,t')}$, 
% 
% $\mathrm{cov}(\dot{x}_k(t), \dot{x}_k(t)) = \frac{\partialC_{\mathbf\phi_k}(t,t') 
% }{\partial t \partial t'} =: C_{\mathbf\phi_k}''(t,t')$.
% 
% 
% 
% 
%% Matching Gradients
% 
% 
% Given the joint distribution over states and their derivatives (3) as well 
% as the ODEs (2), we therefore have two expressions for the state derivatives:
% 
% $\dot{\mathbf{X}} = \mathbf{F} + \mathbf\epsilon_1, \mathbf\epsilon_1 \sim\mathcal{N}\left(\mathbf\epsilon_1;\mathbf{0}, 
% \mathbf{I}\gamma \right)$,
% 
% $\dot{\mathbf{X}} = {'\mathbf{C}_{\phi}} \mathbf{C}_{\phi}^{-1}~\mathbf{X} 
% + \mathbf\epsilon_2, \mathbf\epsilon_2 \sim\mathcal{N}\left(\mathbf\epsilon_2;\mathbf{0}, 
% \mathbf{A} \right)$,
% 
% where $\mathbf{F} := \mathbf{f}(\mathbf{X},\mathbf\theta)$ and $\mathbf{A} 
% :=\mathbf{C}_{\phi}'' -  {'\mathbf{C}_{\phi}} \mathbf{C}_{\phi}^{-1}\mathbf{C}_{\phi}'$ 
% and $\gamma$ is the error variance in the ODEs. Note that, in a deterministic 
% system, the output of the ODEs $\mathbf{F}$ should equal the state derivatives 
% $\dot{\mathbf{X}}$. However, in the first equation above we relax this contraint 
% by adding stochasticity to the state derivatives $\dot{\mathbf{X}}$ in order 
% to compensate for a
% 
% potential model mismatch. The second equation above is obtained by deriving 
% the conditional distribution for $\dot{\mathbf{X}}$ from the joint distribution 
% in equation (3). Equating the two expressions in the equations above we can 
% eliminate the unknown state derivatives $\dot{\mathbf{X}$:
% 
% $\mathbf{F} = {'\mathbf{C}_{\phi}} \mathbf{C}_{\phi}^{-1} ~\mathbf{X} +\mathbf\epsilon_0 
% \qquad (4)$,
% 
% with $\mathbf{\epsilon_0} := \mathbf{\epsilon_2} - \mathbf{\epsilon_1}$.
% 
% 
%%
[dC_times_invC,inv_C,A_plus_gamma_inv] = kernel_function(kernel,state,time.est);
%% 
% 
%% Rewrite ODEs as Linear Combination in Parameters
% 
% 
% Since, according to the mass action dynamics (equation 2), the ODEs are 
% _*linear in the parameters *_$\mathbf\theta$ we can rewrite the ODEs in equation 
% (2) as a linear combination in the parameters:
% 
% $\mathbf{B}_{\mathbf{\theta} k} \mathbf{\theta} + \mathbf{b}_{\mathbf{\theta} 
% k} \stackrel{!}{=}\mathbf{f}_k(\mathbf{X},\mathbf{\theta}) \qquad (5)$,
% 
% where matrices $\mathbf{B}_{\mathbf{\theta} k}$ and $\mathbf{b}_{\mathbf{\theta} 
% k}$ are defined such that the ODEs $\mathbf{f}_k(\mathbf{X},\mathbf{\theta})$ 
% are expressed as a linear combination in $\mathbf{\theta}$.
% 
% 
%%
[ode_param.lin_comb.B,ode_param.lin_comb.b] = rewrite_odes_as_linear_combination_in_parameters(ode,symbols);
%% 
% 
%% Posterior over ODE Parameters
% 
% 
% Inserting (5) into (4) and solving for $$\mathbf{\theta}$$ yields:
% 
% $\mathbf{\theta} = \mathbf{B}_{\mathbf{\theta}}^+ \left( {'\mathbf{C}_{\mathbf{\phi}}}\mathbf{C}_{\mathbf{\phi}}^{-1} 
% \mathbf{X} - \mathbf{b}_{\mathbf{\theta}} + \mathbf{\epsilon_0}\right)$,
% 
% where $\mathbf{B}_{\mathbf{\theta}}^+$ denotes the pseudo-inverse of $\mathbf{B}_{\mathbf{\theta}}$. 
% Since $$\mathbf{C}_{\mathbf{\phi}}$$ is block diagonal we can rewrite the expression 
% above as:
% 
% $\mathbf{\theta} = \left( \mathbf{B}_{\mathbf{\theta}}^T \mathbf{B}_{\mathbf{\theta}} 
% \right)^{-1} ~\mathbf{B}_{\mathbf{\theta}}^T  \left( \sum_k {'\mathbf{C}_{\mathbf{\phi}_k}}\mathbf{C}_{\mathbf{\phi}_k}^{-1} 
% \mathbf{X}_k - \mathbf{b}_{\mathbf{\theta} k} + \mathbf{\epsilon_0}^{(k)} \right)\\ 
% ~= \left( \mathbf{B}_{\mathbf{\theta}}^T \mathbf{B}_{\mathbf{\theta}} \right)^{-1} 
% \left(\sum_k \mathbf{B}_{\mathbf{\theta} k}^T \left( {'\mathbf{C}_{\mathbf{\phi}_k}}\mathbf{C}_{\mathbf{\phi}_k}^{-1} 
% \mathbf{X}_k - \mathbf{b}_{\mathbf{\theta} k} +\mathbf{\epsilon_0}^{(k)} \right) 
% \right)$,
% 
% where we subsitute the Moore-Penrose inverse for the pseudo-inverse (i.e. 
% $\mathbf{B}_{\mathbf{\theta}}^+ := \left( \mathbf{B}_{\mathbf{\theta}}^T \mathbf{B}_{\mathbf{\theta}}\right)^{-1} 
% \mathbf{B}_{\mathbf{\theta}}^T$). We can therefore derive the posterior distribution 
% over ODE parameters:
% 
% $p(\mathbf{\theta} \mid \mathbf{X}, \mathbf{\phi}, \gamma) = \mathcal{N}\left(\mathbf{\theta} 
% ; \left( \mathbf{B}_{\mathbf{\theta}}^T\mathbf{B}_{\mathbf{\theta}} \right)^{-1} 
% \left( \sum_k \mathbf{B}_{\mathbf{\theta} k}^T ~\left( {'\mathbf{C}_{\mathbf{\phi} 
% k}} \mathbf{C}_{\mathbf{\phi} k}^{-1} \mathbf{X}_k -\mathbf{b}_{\mathbf{\theta} 
% k} \right) \right), ~ \mathbf{B}_{\mathbf{\theta}}^+ ~(\mathbf{A} + \mathbf{I}\gamma) 
% ~ \mathbf{B}_{\mathbf{\theta}}^{+T} \qquad (6)$.
%% 
% 
%% Rewrite Hemodynamic ODEs as Linear Combination in (monotonic functions of) Individual Hemodynamic States
% 
% 
% * *Deoxyhemoglobin content *
% 
%                 Rewrite the BOLD signal change equation as a linear combination 
% in a monotonic function of the deoxyhemoglobin content $$\exp(\mathbf{q})$$:
% 
%                 $$\mathbf{R}_{q~\mathbf\lambda} ~ \exp(\mathbf{q}) ~+ ~ 
% \mathbf{r}_{v~\mathbf\lambda} \stackrel{!}{=} ~\mathbf\lambda(\mathbf{q},\mathbf{v})$$.
%%
         [state.deoxyhemo.R,state.deoxyhemo.r] = rewrite_bold_signal_eqn_as_linear_combination_in_deoxyhemo(symbols);
%% 
% **
% 
% * *Blood volume*
% 
%                 Rewrite the deoxyhemoglobin content ODE as a linear combination 
% in a monotonic function of the blood volume $\exp\left( 17 / 8 ~\mathbf{v}\right)$:
% 
%                  $\mathbf{R}_{v\dot{q}} ~\exp\left( 17 / 8 ~\mathbf{v}\right) 
% ~+~ \mathbf{r}_{v\dot{q}} \stackrel{!}{=} \mathbf{f}_{\dot{q}}(\mathbf{X},\mathbf\theta)$.

         [state.vol.R,state.vol.r] = rewrite_deoxyhemo_ODE_as_linear_combination_in_vol(ode,symbols);
%% 
% **
% 
% * *Blood flow*
% 
%                 Rewrite the blood volume ODE as a linear combination in 
% a monotonic function of the blood flow $\exp(\mathbf{f})$.
% 
%                    $$\mathbf{R}_{f~\dot{v}} ~ \exp(\mathbf{f}) + \mathbf{r}_{f~\dot{v}} 
% \stackrel{!}{=} \mathbf{f}_{\dot{v}}(\mathbf{X},\mathbf\theta)$$.    

        [state.flow.R,state.flow.r] = rewrite_vol_ODE_as_linear_combination_in_flow(ode,symbols);
%% 
% * *Vasosignalling*
% 
%                 Rewrite the blood flow and vasoginalling ODEs as a linear 
% combination in vasosignalling $\mathbf{s}$.
% 
%                     $$\mathbf{R}_{s\dot{f}} ~\mathbf{s} + \mathbf{r}_{s\dot{f}} 
% \stackrel{!}{=} \mathbf{f}_{\dot{f}}(\mathbf{X},\mathbf\theta)$$.
% 
%                     $$\mathbf{R}_{s\dot{s}}~ \mathbf{s} + \mathbf{r}_{s\dot{s}} 
% \stackrel{!}{=} \mathbf{f}_{\dot{s}}(\mathbf{X},\mathbf\theta)$$.

         [state.vaso.R,state.vaso.r] = rewrite_vaso_and_flow_odes_as_linear_combination_in_vaso(ode,symbols);
%% 
% 
% 
% 
%% Rewrite Neuronal ODEs as Linear Combination in Individual Neuronal States
% 
% 
% We rewrite the ODE(s) $$\mathbf{f}_k(\mathbf{X},\mathbf\theta)$$ as a linear 
% combination in the individual state $$\mathbf{n}_u$$:
% 
%         $$\mathbf{R}_{uk}  \mathbf{n}_u + \mathbf{r}_{uk} \stackrel{!}{=} 
% \mathbf{f}_{k}(\mathbf{X},\mathbf\theta)$$,
% 
% where matrices $$\mathbf{R}_{uk}$$ and $\mathbf{r}_{uk}$ are defined such 
% that the ODE $$\mathbf{f}_k(\mathbf{X},\mathbf\theta)$$ is expressed as a linear 
% combination in the individual state $$\mathbf{n}_u$$.
%%
[state.neuronal.R,state.neuronal.r] = rewrite_odes_as_linear_combination_in_ind_neuronal_states(ode,symbols,coupling_idx.states);
%% 
% 
%% Posterior over Individual States
% 
% 
% Given the linear combination of the ODEs w.r.t. an individual state, we 
% define the matrices $\mathbf{B}_u$ and $\mathbf{b}_u$ such that the expression 
% $$\mathbf{f}(\mathbf{X},\mathbf{\theta}) - {'\mathbf{C}}_{\mathbf{\phi}}\mathbf{C}_{\mathbf{\phi}}^{-1} 
% \mathbf{X}$$ is rewritten as a linear combination in an individual state $\mathbf{x}_u$:
% 
% $\mathbf{B}_{u} \mathbf{x}_u + \mathbf{b}_{u} \stackrel{!}{=}\mathbf{f}(\mathbf{X},\mathbf{\theta}) 
% - {'\mathbf{C}}_{\mathbf{\phi}}\mathbf{C}_{\mathbf{\phi}}^{-1} \mathbf{X} \qquad 
% (7)$.
% 
% Inserting (7) into (4) and solving for $$\mathbf{x}_u$$ yields:
% 
% $$\mathbf{x}_u = \mathbf{B}_{u}^+ \left( \mathbf{\epsilon_0} -\mathbf{b}_{u}\right)$$,
% 
% where $$\mathbf{B}_{u}^+$$ denotes the pseudo-inverse of $$\mathbf{B}_{u}$$. 
% Since $$\mathbf{C}_{\mathbf{\phi}}$$ is block diagonal we can rewrite the expression 
% above as:
% 
% $\mathbf{x}_u = \left( \mathbf{B}_{u} \mathbf{B}_{u}^T \right)^{-1}\mathbf{B}_{u}^T 
% \sum_k \left(\mathbf{\epsilon_0}^{(k)} -\mathbf{b}_{uk} \right)\\ \quad= \left( 
% \mathbf{B}_{u} \mathbf{B}_{u}^T \right)^{-1} \sum_k\mathbf{B}_{uk}^T \left(\mathbf{\epsilon_0}^{(k)} 
% -\mathbf{b}_{uk} \right)$,
% 
% where we subsitute the Moore-Penrose inverse for the pseudo-inverse (i.e. 
% $\mathbf{B}_{\mathbf{\theta}}^+ := \left( \mathbf{B}_{\mathbf{\theta}}^T \mathbf{B}_{\mathbf{\theta}}\right)^{-1} 
% \mathbf{B}_{\mathbf{\theta}}^T$).  We can therefore derive the posterior distribution 
% over an individual state $$\mathbf{x}_{u}$$:
% 
% $p(\mathbf{x}_u \mid \mathbf{X}_{-u}, \mathbf{\phi}, \gamma)= \mathcal{N}\left(\mathbf{x}_u 
% ; \left( \mathbf{B}_{u} \mathbf{B}_{u}^T\right)^{-1} \left( - \sum_k \mathbf{B}_{uk}^T 
% \mathbf{b}_{uk} \right),~\mathbf{B}_{u}^{+} ~ (\mathbf{A} + \mathbf{I}\gamma) 
% ~ \mathbf{B}_u^{+T}\right) \qquad (8)$,
% 
% with $$\mathbf{X}_{-u}$$ denoting the set of all states except state $$\mathbf{x}_u$$. 
%% 
% 
%% Mean-field Variational Inference
% 
% 
% To infer the parameters $$\mathbf{\theta}$$, we want to find the maximum 
% a posteriori estimate (MAP):
% 
% $\mathbf{\theta}^* := \mathrm{arg} \max_{\mathbf{\theta}} ~ \ln p(\mathbf{\theta} 
% \mid\mathbf{Y},\mathbf{\phi},\gamma,\mathbf \sigma)\\ \quad= \mathrm{arg}\max_{\mathbf{\theta}} 
% ~ \ln \int  p(\mathbf{\theta},\mathbf{X} \mid\mathbf{Y},\mathbf{\phi},\gamma,\mathbf\sigma) 
% d\mathbf{X}\\ \quad= \mathrm{arg}\max_{\mathbf{\theta}} ~ \ln \int p(\mathbf{\theta} 
% \mid \mathbf{X},\mathbf{\phi},\gamma)p(\mathbf{X} \mid \mathbf{Y}, \mathbf{\phi},\mathbf\sigma) 
% d\mathbf{X} \qquad(9)$.
% 
% However, the integral above is intractable due to the strong couplings 
% induced by the nonlinear ODEs $$\mathbf{f}$$ which appear in the term $$p(\mathbf{\theta} 
% \mid \mathbf{X},\mathbf{\phi},\gamma)$$.
% 
% We use mean-field variational inference to establish variational lower 
% bounds that are analytically tractable by decoupling state variables from the 
% ODE parameters as well as decoupling the state variables from each other. Note 
% that, since the ODEs described by equation (2) are _*locally linear_*, both 
% conditional distributions $$p(\mathbf{\theta} \mid\mathbf{X},\mathbf{Y},\mathbf{\phi},\gamma,\mathbf\sigma)$$ 
% (equation (6)) and $$p(\mathbf{x}_u \mid \mathbf{\theta},\mathbf{X}_{-u},\mathbf{Y},\mathbf{\phi},\gamma,\mathbf\sigma)$$ 
% (equation (8)) are analytically tractable and Gaussian distributed as mentioned 
% previously. The decoupling is induced by designing a variational distribution 
% $$Q(\mathbf{\theta},\mathbf{X})$$ which is restricted to the family of factorial 
% distributions:
% 
% $$\mathcal{Q} := \bigg{\{} Q : Q(\mathbf{\theta},\mathbf{X}) = q(\mathbf{\theta}) 
% \prod_uq(\mathbf{x}_u) \bigg{\}}$$.
% 
% The particular form of $$q(\mathbf{\theta})$$ and $$q(\mathbf{x}_u)$$ are 
% designed to be Gaussian distributed which places them in the same family as 
% the true full conditional distributions. To find the optimal factorial distribution 
% we minimize the Kullback-Leibler divergence between the variational and the 
% true posterior distribution:
% 
% $$\hat{Q} := \mathrm{arg} \min_{Q(\mathbf{\theta},\mathbf{X}) \in \mathcal{Q}} 
% \mathrm{KL}\left[ Q(\mathbf{\theta},\mathbf{X}) \mid \mid p(\mathbf{\theta},\mathbf{X} 
% \mid\mathbf{Y},\mathbf{\phi}, \gamma,\mathbf\mathbf{\sigma}) \right] \qquad 
% (10)$$,
% 
% where $$\hat{Q}$$ is the proxy distribution. The proxy distribution that 
% minimizes the KL-divergence (10) depends on the true full conditionals and is 
% given by:
% 
% $\hat{q}({\mathbf{\theta}}) \propto \exp \left(~ E_{Q_{-\mathbf{\theta}}} 
% \ln p(\mathbf{\theta} \mid\mathbf{X},\mathbf{Y},\mathbf{\phi},\gamma,\mathbf\mathbf{\sigma}) 
% ~\right) \qquad (11)\\\hat{q}(\mathbf{x}_u) \propto \exp\left( ~ E_{Q_{-u}} 
% \ln p(\mathbf{x}_u\mid \mathbf{\theta}, \mathbf{X}_{-u},\mathbf{Y},\mathbf{\phi},\gamma,\mathbf{\sigma}) 
% ~ \right)\qquad (12)$.
%% 
%% 
%% Denoising BOLD Observations
%% 
% We denoise the BOLD observation by standard GP regression.
%%
bold_response.denoised_obs = denoising_BOLD_observations(simulation.bold_response{:,{'n_1','n_3','n_2'}},inv_C,symbols,simulation);
%% 
% 
%% Fitting observations of state trajectories
% 
% 
% We fit the observations of state trajectories by standard GP regression. 
% The data-informed distribution$ $p(\mathbf{X} \mid \mathbf{Y}, \mathbf{\phi},\mathbf\mathbf{\sigma})$$ 
% in euqation (9) can be determined analytically using Gaussian process regression 
% with the GP prior $$p(\mathbf{X} \mid\mathbf{\phi}) = \prod_k \mathcal{N}(\mathbf{x}_k 
% ;\mathbf{0},\mathbf{C}_{\mathbf{\phi}})$$:
% 
% $$p(\mathbf{X} \mid \mathbf{Y}, \mathbf{\phi},\gamma) = \prod_k\mathcal{N}(\mathbf{x}_k 
% ;\mathbf\mu_k(\mathbf{y}_k),\mathbf\mathbf{\sigma}_k)$$,
% 
% where $$\mathbf\mu_k(\mathbf{y}_k) := \mathbf{\sigma}_k^{-2} \left(\mathbf{\sigma}_k^{-2}\mathbf{I} 
% + \mathbf{C}_{\mathbf{\phi}_k}^{-1} \right)^{-1} \mathbf{y}_k$$ and $$\mathbf{\sigma}_k 
% ^{-1}:=\mathbf{\sigma}_k^{-2} \mathbf{I} +\mathbf{C}_{\mathbf\mathbf{\phi}_k}^{-1}$$.
% 
% 
%%
[mu,inv_sigma] = fitting_state_observations(inv_C,obs_to_state_relation,simulation,symbols);
%% 
% 
%% Coordinate Ascent Variational Gradient Matching
% 
% 
% We minimize the KL-divergence in equation (10) by coordinate descent (where 
% each step is analytically tractable) by iterating between determining the proxy 
% for the distribution over ODE parameters $$\hat{q}(\mathbf{\theta})$$ and the 
% proxies for the distribution over individual states $$\hat{q}(\mathbf{x}_u)$$.
% 
% 
% 
% * *Initialize the state estimation by the GP regression posterior*
%%
            state.proxy.mean = array2table([time.est',mu],'VariableNames',['time',symbols.state_string]);
            bold_response.obs_old = bold_response.denoised_obs;
            ode_param.proxy.mean = zeros(length(symbols.param),1);
%% 
% **
% 
% * *Coordinate ascent*

            for i = 1:opt_settings.coord_ascent_numb_iter
%% *                           *
%% *Intercept due to Confounding Effects*
% The intercept is determined by a minimum least squares estimator:
% 
% $\mathbf{X} \hat{\beta} := \mathbf{X} ( \mathbf{X}^T \mathbf{X} )^{-1} 
% \mathbf{X}^T (\mathbf{y} - \mathbf{\lambda}(\mathbf{q},\mathbf{v}))$.
%%
%                 bold_response_signal_change = bold_signal_change_eqn(state.proxy.mean{:,'v_1','v_2','v_3'},...
%                     state.proxy.mean{:,'q_1','q_2','q_3'});
%                 bold_response.confounding_effects.intercept = determine_intercept(bold_response.obs_old-bold_response_signal_change,...
%                     bold_response.confounding_effects.X0,bold_response.confounding_effects.X0_penrose_inv);
%                 
                bold_response.confounding_effects.intercept = zeros(height(simulation.bold_response),width(simulation.bold_response)-1);
                bold_response.denoised_obs = bold_response.obs_old - bold_response.confounding_effects.intercept; 
%% 
% 
%% 
%% 
%% Proxy for Hemodynamic States
%   
% 
% Determine the proxies for the states, starting with deoxyhemoglobin followed 
% by blood volume, blood flow and finally vasosignalling. The information flow 
% in the hemodynamic system is shown in its factor graph below:
% 
% .
% 
% The model inversion in the hemodynmic factor graph above occurs locally 
% w.r.t. individual states. Given the expression for the BOLD signal change equation, 
% we invert the BOLD signal change equation analytically to determine the deoxyhemoglobin 
% content $$\mathbf{q}$$ (1). The newly inferred deoxyhemoglobin content $$\mathbf{q}$$ 
% influences the expression for the factor associated with the change in deoxyhemoglobin 
% content $$\mathbf{h}_{\dot{\mathbf{q}}}$$, which we subsequently invert analytically 
% to infer the blood volume $\mathbf{v}$ (2). Thereafter, we infer the blood flow 
% $$\mathbf{f}$$ (3) by inverting the factors associated with the change in blood 
% volume $$\mathbf{h}_{\dot{\mathbf{v}}}$$ as well as vasosignalling $$\mathbf{h}_{\dot{\mathbf{s}}}$$, 
% followed by inferring vasosignalling $$\mathbf{s}$$ (4) by inverting the factors 
% associated with blood flow induction $$\mathbf{h}_{\dot{\mathbf{f}}}$$ and vasosignalling 
% $$\mathbf{h}_{\dot{\mathbf{s}}}$$. Finally, the neuronal dynamics (5) are learned, 
% in part, by inverting the factor associated with vasosignalling $$\mathbf{h}_{\dot{\mathbf{s}}}$$. 
% The typical trajectories of each of the states are shown (red) together with 
% their iterative approximation (grey lines) obtained by graphical DCM.
% 
% 
% 
% * *Proxy for deoxyhemolgobin content*
% 
%                 Damping is required since we invert only the factor for 
% the BOLD signal change equation w.r.t. a monotonic function of deoxyhemoglobin 
% content $\exp( \mathbf{q})$.
% 
%                            * Undamped proxy:*
%%
                state_proxy_undamped = proxy_for_deoxyhemoglobin_content(state.deoxyhemo,state.proxy.mean{:,symbols.state_string},...
                    bold_response.denoised_obs,symbols,A_plus_gamma_inv,opt_settings);
%% 
%                            * Damped proxy:*

                state.proxy.mean{:,{'q_1','q_3','q_2'}} = (1-opt_settings.damping) * state.proxy.mean{:,{'q_1','q_3','q_2'}} + ...
                    opt_settings.damping * state_proxy_undamped;
%% 
%  
% 
% * *Proxy for blood volume*
% 
% *              *    Damping is required since we invert only the a subset 
% of ODEs w.r.t. a monotonic function of blood volume $\exp\left( 17/ 8 ~ \mathbf{v} 
% \right)$.
% 
% *                            Undamped proxy:*

                state_proxy_undamped = proxy_for_blood_volume(state.vol,dC_times_invC,state.proxy.mean{:,symbols.state_string},...
                    ode_param.proxy.mean,symbols,A_plus_gamma_inv,opt_settings);
%% 
%                             *Damped proxy:*

                state.proxy.mean{:,{'v_1','v_3','v_2'}} = (1-opt_settings.damping) * state.proxy.mean{:,{'v_1','v_3','v_2'}} + ...
                    opt_settings.damping * state_proxy_undamped;
%% 
% **
% 
% * *Proxy for blood flow*
% 
%                 Damping is required since we invert only the a subset of 
% ODEs w.r.t. a mononic function of blood flow $\exp(\mathbf{f})$.
% 
%                             *Undamped proxy:*

                state_proxy_undamped = proxy_for_blood_flow(state.flow,dC_times_invC,state.proxy.mean{:,symbols.state_string},...
                    ode_param.proxy.mean,symbols,A_plus_gamma_inv,opt_settings);
%% 
%                             *Damped proxy:*

                state.proxy.mean{:,{'f_1','f_3','f_2'}} = (1-opt_settings.damping) * state.proxy.mean{:,{'f_1','f_3','f_2'}} + ...
                    opt_settings.damping * state_proxy_undamped;
%% 
% **
% 
% * *Proxy for vasosignalling*
% 
%                 No damping is required because we invert all ODEs w.r.t. 
% vasosingalling $\mathbf{s}$.

                state.proxy.mean{:,{'s_1','s_3','s_2'}} = proxy_for_vasosignalling(state.vaso,dC_times_invC,...
                    state.proxy.mean{:,symbols.state_string},ode_param.proxy.mean,symbols,A_plus_gamma_inv,opt_settings);
%% 
% **
%%         Proxy for Neuronal States
% 
% 
% *            *Determine the proxies for the neuronal states. An example 
% of the information flow in the neuronal part of the nonlinear forward modulating 
% (nonlin_fwd_mod) is shown in its factor graph below:
% 
% .
% 
%             In the neuronal factor graph (for the nonlinear forwad modulation) 
% above each individual state appears linear in every factor in the neuronal model. 
% We can therefore analytically invert every factor to determine the neuronal 
% state. The typical trajectories of each of the states are shown (red) together 
% with their iterative approximation (grey lines) obtained by variational gradient 
% matching.
% 
% 
% 
% No damping is required because we invert all ODEs w.r.t. neuronal populations 
% $\mathbf{n}$.
%%
            state.proxy.mean{:,{'n_1','n_3','n_2'}} = proxy_for_neuronal_populations(state.neuronal,...
                state.proxy.mean{:,symbols.state_string},ode_param.proxy.mean',dC_times_invC,...
                coupling_idx.states,symbols,A_plus_gamma_inv,opt_settings);
%% 
% **
% 
% *Keep initial value at zero*

            state_idx = cellfun(@(x) ~strcmp(x(1),'u'),symbols.state_string);
            state.proxy.mean{1,state_idx} = bsxfun(@minus,state.proxy.mean{1,state_idx},state.proxy.mean{1,state_idx});
%% *            *
%% **
%% *Proxy for ODE parameters*
%                     Expanding the proxy distribution in equation (11) for 
% $$\mathbf{\theta}$$ yields:
% 
%                            $\hat{q}(\mathbf{\mathbf\theta}) \propto \exp 
% \left( ~E_{Q_{-\mathbf\theta}}     \ln p(\theta \mid \mathbf{X},\mathbf{Y},\mathbf\phi,\gamma,\mathbf\sigma) 
% ~     \right) \\ \qquad= \exp \left( ~E_{Q_{-\mathbf{\theta}}} \ln \mathcal{N}\left(\mathbf{\theta} 
% ; \left(    \mathbf{B}_{\mathbf{\theta}}^T \mathbf{B}_{\mathbf{\theta}} \right)^{-1} 
% \left( \sum_k    \mathbf{B}_{\mathbf{\theta} k}^T ~ \left( {'\mathbf{C}_{\mathbf{\phi} 
% k}}    \mathbf{C}_{\mathbf{\phi} k}^{-1} \mathbf{X}_k - \mathbf{b}_{\mathbf{\theta} 
% k} \right)    \right), ~ \mathbf{B}_{\mathbf{\theta}}^+ ~ (\mathbf{A} + \mathbf{I}\gamma) 
% ~    \mathbf{B}_{\mathbf{\theta}}^{+T} \right) ~\right)$,
% 
%                     where we substitute $$p(\mathbf{\theta} \mid \mathbf{X},\mathbf{\phi},\gamma)$$ 
% with its density given in equation (6).
% 
% 
% 
%                     No damping is required because we invert all ODEs w.r.t. 
% neuronal couplings $\mathbf{\theta}$.
%%
            if i>200 || i==opt_settings.coord_ascent_numb_iter
                [ode_param.proxy.mean,ode_param.proxy.inv_cov] = proxy_for_ode_parameters(...
                    state.proxy.mean{:,symbols.state_string},dC_times_invC,ode_param.lin_comb,...
                    symbols,A_plus_gamma_inv,opt_settings);
            end
%% 
% 

            if i==1 || ~mod(i,20)
                plot_results(fig_handle,state,simulation,ode_param.proxy.mean,plot_handle,symbols,plot_settings,'not_final');
            end           
%% 
% **

end
%% **
%% **
%% *Numerical Integration with Estimated ODE Parameters*
% See whether we actually fit the BOLD responses well. Curves are shown in black.
%%
simulation2 = simulation_old; simulation2.ode_param = ode_param.proxy.mean';
[simulation2,obs_to_state_relation] = simulate_state_dynamics_dcm(simulation2,symbols,ode,time,...
    plot_settings,state.ext_input,'no plot');
state.proxy.num_int = simulation2.state;
%% 
% **
% 
% * *Final result*

            plot_results(fig_handle,state,simulation,ode_param.proxy.mean,plot_handle,symbols,plot_settings,'final');
%% 
% 
%% Time Taken
% 
%%
disp(['time taken: ' num2str(toc) ' seconds'])
%% 
% 
%% References
% 
% 
% *Gorbach, N.S. , Bauer, S. *and Buhmann, J.M., Scalable Variational Inference 
% for Dynamical Systems. 2017a. Neural Information Processing Systems (NIPS). 
% Link to NIPS paper <https://papers.nips.cc/paper/7066-scalable-variational-inference-for-dynamical-systems.pdf 
% here> and arxiv paper <https://arxiv.org/abs/1705.07079 here>.
% 
% *Bauer, S. , Gorbach, N.S.* and Buhmann, J.M., Efficient and Flexible Inference 
% for Stochastic Differential Equations. 2017b. Neural Information Processing 
% Systems (NIPS). Link to NIPS paper <https://papers.nips.cc/paper/7274-efficient-and-flexible-inference-for-stochastic-systems.pdf 
% here>.
% 
% Wenk, P., Gotovos, A., Bauer, S., Gorbach, N.S., Krause, A. and Buhmann, 
% J.M., Fast Gaussian Process Based Gradient Matching for Parameters Identification 
% in Systems of Nonlinear ODEs. 2018. In submission to Conference on Uncertainty 
% in Artificial Intelligence (UAI). Link to arxiv paper <https://arxiv.org/pdf/1804.04378.pdf 
% here>.
% 
% Calderhead, B., Girolami, M. and Lawrence. N.D., 2002. Accelerating Bayesian 
% inference over nonlinear differential equation models. In Advances in Neural 
% Information Processing Systems (NIPS) . 22.
% 
% 
% 
% The authors in bold font have contributed equally to their respective papers.
##### SOURCE END #####
--></body></html>